<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MiniQbt: MiniQbt::Core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MiniQbt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_mini_qbt.html">MiniQbt</a></li><li class="navelem"><a class="el" href="namespace_mini_qbt_1_1_core.html">Core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MiniQbt::Core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_mini_qbt_1_1_core_1_1_tools"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core_1_1_tools.html">Tools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_abstract_register.html">AbstractRegister</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_assembly_version_token.html">AssemblyVersionToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mini_qbt_1_1_core_1_1_bit.html">Bit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_classic_register.html">ClassicRegister</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_classic_register_token.html">ClassicRegisterToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_c_not_token.html">CNotToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_error_token.html">ErrorToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_gate_token.html">GateToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_hadamard_gate_token.html">HadamardGateToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_include_token.html">IncludeToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_linked_register.html">LinkedRegister</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_mass_add_token.html">MassAddToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_measure_token.html">MeasureToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_pauli_x_token.html">PauliXToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_pauli_y_token.html">PauliYToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_pauli_z_token.html">PauliZToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_register_token.html">QuantumRegisterToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_register_composite.html">RegisterComposite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_token.html">Token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_token_visitor.html">TokenVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mini_qbt_1_1_core_1_1_unkown_gate_token.html">UnkownGateToken</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4263713918455b7339f0032c713b8a44"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize&gt; </td></tr>
<tr class="memitem:a4263713918455b7339f0032c713b8a44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a4263713918455b7339f0032c713b8a44">cnotGate</a> (const size_t &amp;control, const size_t &amp;target, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state)</td></tr>
<tr class="separator:a4263713918455b7339f0032c713b8a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4dd6d019f94cda62b577f37a7a46f"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize, bool strictMode = true&gt; </td></tr>
<tr class="memitem:a51a4dd6d019f94cda62b577f37a7a46f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a51a4dd6d019f94cda62b577f37a7a46f">hadamardGate</a> (const size_t &amp;bit_index, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state)</td></tr>
<tr class="separator:a51a4dd6d019f94cda62b577f37a7a46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62027775c22b5d2422c19eed59be69ff"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize, bool strictMode = true&gt; </td></tr>
<tr class="memitem:a62027775c22b5d2422c19eed59be69ff"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; registerSize &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a62027775c22b5d2422c19eed59be69ff">measure</a> (<a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state, std::default_random_engine &amp;generator)</td></tr>
<tr class="separator:a62027775c22b5d2422c19eed59be69ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebef3ee9ebc7021dd178dc4e84239df"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize&gt; </td></tr>
<tr class="memitem:a1ebef3ee9ebc7021dd178dc4e84239df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a1ebef3ee9ebc7021dd178dc4e84239df">pauliY</a> (const size_t &amp;bit_index, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state)</td></tr>
<tr class="separator:a1ebef3ee9ebc7021dd178dc4e84239df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab996664e3373dbbc15e88642df859c75"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize&gt; </td></tr>
<tr class="memitem:ab996664e3373dbbc15e88642df859c75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#ab996664e3373dbbc15e88642df859c75">pauliZ</a> (const size_t &amp;bit_index, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state)</td></tr>
<tr class="separator:ab996664e3373dbbc15e88642df859c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cdc32734561c1df1f2af418394ad4f"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize&gt; </td></tr>
<tr class="memitem:a39cdc32734561c1df1f2af418394ad4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a39cdc32734561c1df1f2af418394ad4f">pauliX</a> (const size_t &amp;bit_index, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state)</td></tr>
<tr class="separator:a39cdc32734561c1df1f2af418394ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8656dcfbf26941378d33771af19761"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize&gt; </td></tr>
<tr class="memitem:a9a8656dcfbf26941378d33771af19761"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a9a8656dcfbf26941378d33771af19761">phaseS</a> (const size_t &amp;bit_index, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state, bool transpose=false)</td></tr>
<tr class="separator:a9a8656dcfbf26941378d33771af19761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81ec925af3b01474f04af8953e23802"><td class="memTemplParams" colspan="2">template&lt;size_t registerSize&gt; </td></tr>
<tr class="memitem:ad81ec925af3b01474f04af8953e23802"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#ad81ec925af3b01474f04af8953e23802">phaseT</a> (const size_t &amp;bit_index, <a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;state, bool transpose=false)</td></tr>
<tr class="separator:ad81ec925af3b01474f04af8953e23802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738c07d973d45d30bec784c552d96d80"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_mini_qbt_1_1_core_1_1_token.html">Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a738c07d973d45d30bec784c552d96d80">parseToken</a> (const std::string &amp;line)</td></tr>
<tr class="separator:a738c07d973d45d30bec784c552d96d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5de6ee09291f78453a79335973c555"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_mini_qbt_1_1_core_1_1_token.html">Token</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_mini_qbt_1_1_core.html#a2d5de6ee09291f78453a79335973c555">parseExpressions</a> (const std::string &amp;line)</td></tr>
<tr class="separator:a2d5de6ee09291f78453a79335973c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4263713918455b7339f0032c713b8a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4263713918455b7339f0032c713b8a44">&#9670;&nbsp;</a></span>cnotGate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::cnotGate </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies a controlled not gate on a quantum state.  Heiko van der Heijden</p>
<p>See the quantum state as a array wherein the index corresponds to the binary resperentation. Such as (register size 2) [0 == 00, 1 == 01, 2 == 10, 3 == 11]. When you want to flip bit 0 based on bit 1. It will just ignore the bits where the bit control bit is 0, thus it will create a new array [2,3]. After that the bit that's the same with only the target bit different will be found (no matter the registersize this is always 2) And reverses the value of each of this values [0, 1, 3, 2] is the new order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registerSize,the</td><td>size a quantum register. </td></tr>
    <tr><td class="paramname">control,the</td><td>quantum bit you wish to use as control, this bit will remain the same. </td></tr>
    <tr><td class="paramname">target,the</td><td>quantum bit you wish to use as target, this bit will be flipped if the control is 1. </td></tr>
    <tr><td class="paramname">state,the</td><td>state that will be altered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_mini_qbt_1_1_quantum_exception.html">QuantumException</a>,when</td><td>the an invalid bit is altered it will throw a quantum exception </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a4dd6d019f94cda62b577f37a7a46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4dd6d019f94cda62b577f37a7a46f">&#9670;&nbsp;</a></span>hadamardGate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize, bool strictMode = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::hadamardGate </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>bit_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the hadamard gate (and thus place the state in superposition) on the specified quantumstate.  Heiko van der Heijden</p>
<p>See the quantum state as a array wherein the index corresponds to the binary resperentation. Such as (register size 2) [0 == 00, 1 == 01, 2 == 10, 3 == 11]. And we want to apply the hadamard on bit zero The hadamard stores temporarily the order of the quantum state, and searches for each bit the twin bit (the bit that only differs in the control bit this is always two bits) It multiplies the bit with the 1 over squareroot(2) and increments/substracts it with the multiplication of F with the targetbit depending on if it's a 1 or 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registerSize,the</td><td>size of the register </td></tr>
    <tr><td class="paramname">strictMode,Allows</td><td>collapsed registers </td></tr>
    <tr><td class="paramname">bit_index,The</td><td>bit you want to apply the hadamard gate </td></tr>
    <tr><td class="paramname">state,The</td><td>state containing all the information </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_mini_qbt_1_1_quantum_exception.html">QuantumException</a></td><td>When the program is in strictmode and is already collapsed, also when the controlbit is invalid </td></tr>
  </table>
  </dd>
</dl>
<p>this is 1 divided by square root of 2</p>

</div>
</div>
<a id="a62027775c22b5d2422c19eed59be69ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62027775c22b5d2422c19eed59be69ff">&#9670;&nbsp;</a></span>measure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize, bool strictMode = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt;registerSize&gt; MiniQbt::Core::measure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measures a quantumstate and returns the classic bitset.  Heiko van der Heijden</p>
<p>See the quantum state as a array wherein the index corresponds to the binary resperentation. Such as (register size 2) [0 == 00, 1 == 01, 2 == 10, 3 == 11]. When we want to measure the register we need to take a random number between 0 and 1. The quantumstate has for each index a specific value for example |0&gt;. [chance 1.0 index 0 bitvalue 0, chance 0.0 index 1 bitvalue 1]. We take the norm of each index and checks if it's more then the random number provided if so then the bitvalue of that specific index is the answer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registerSize,the</td><td>size of the quantumregister </td></tr>
    <tr><td class="paramname">strictmode,Throw</td><td>a exception when the register is already measured </td></tr>
    <tr><td class="paramname">state,The</td><td>state you wish to measure </td></tr>
    <tr><td class="paramname">generator,The</td><td>generator deciding the random number </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_mini_qbt_1_1_quantum_exception.html">QuantumException</a>,When</td><td>the state is already collapsed in strictmode or when the state was invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d5de6ee09291f78453a79335973c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5de6ee09291f78453a79335973c555">&#9670;&nbsp;</a></span>parseExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_mini_qbt_1_1_core_1_1_token.html">MiniQbt::Core::Token</a> &gt; &gt; MiniQbt::Core::parseExpressions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an entire string for a list of tokens. </p>

</div>
</div>
<a id="a738c07d973d45d30bec784c552d96d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738c07d973d45d30bec784c552d96d80">&#9670;&nbsp;</a></span>parseToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_mini_qbt_1_1_core_1_1_token.html">MiniQbt::Core::Token</a> &gt; MiniQbt::Core::parseToken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a single token. </p>

</div>
</div>
<a id="a39cdc32734561c1df1f2af418394ad4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cdc32734561c1df1f2af418394ad4f">&#9670;&nbsp;</a></span>pauliX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::pauliX </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>bit_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ebef3ee9ebc7021dd178dc4e84239df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebef3ee9ebc7021dd178dc4e84239df">&#9670;&nbsp;</a></span>pauliY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::pauliY </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>bit_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab996664e3373dbbc15e88642df859c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab996664e3373dbbc15e88642df859c75">&#9670;&nbsp;</a></span>pauliZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::pauliZ </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>bit_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a8656dcfbf26941378d33771af19761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8656dcfbf26941378d33771af19761">&#9670;&nbsp;</a></span>phaseS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::phaseS </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>bit_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad81ec925af3b01474f04af8953e23802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81ec925af3b01474f04af8953e23802">&#9670;&nbsp;</a></span>phaseT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t registerSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MiniQbt::Core::phaseT </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>bit_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mini_qbt_1_1_core_1_1_quantum_state.html">QuantumState</a>&lt; registerSize &gt; &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
